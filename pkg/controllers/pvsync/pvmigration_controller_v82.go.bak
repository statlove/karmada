package pvsync
import (
	"context"
	"fmt"
	"sync"
	"crypto/sha1"
	"encoding/hex"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/client-go/tools/record"
	"k8s.io/client-go/util/retry"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"k8s.io/klog/v2"
	"sigs.k8s.io/yaml"
	workv1alpha1 "github.com/karmada-io/karmada/pkg/apis/work/v1alpha1"
	workv1alpha2 "github.com/karmada-io/karmada/pkg/apis/work/v1alpha2"
	"github.com/karmada-io/karmada/pkg/util/helper"
	"github.com/karmada-io/karmada/pkg/util/names"
	"github.com/karmada-io/karmada/pkg/controllers/ctrlutil"

)
const PVMigrationControllerName = "pv-migration-controller"
type PVMigrationController struct {
	client.Client
	EventRecorder record.EventRecorder
	RESTMapper    meta.RESTMapper
}
func (c *PVMigrationController) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	klog.Infof("[PVMigrationController] Reconciling ResourceBinding")

	rb := &workv1alpha2.ResourceBinding{}
	if err := c.Client.Get(ctx, req.NamespacedName, rb); err != nil {
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}
	// 1. Check target is StatefulSet
	if rb.Spec.Resource.Kind != "StatefulSet" || rb.Spec.Resource.APIVersion != "apps/v1" {
		return ctrl.Result{}, nil
	}
	// 2. Check if any cluster reports "Unhealthy"
	unhealthy := false
	for _, s := range rb.Status.AggregatedStatus {
		if s.Health == "Unhealthy" {
			unhealthy = true
			break
		}
	}
	if !unhealthy {
		return ctrl.Result{}, nil
	}
	// 3. Check if dispatching is suspended
	if rb.Spec.Suspension != nil && rb.Spec.Suspension.Dispatching != nil && *rb.Spec.Suspension.Dispatching {
		klog.Infof("[Matched RB] %s/%s: Unhealthy StatefulSet, dispatching suspended", rb.Namespace, rb.Name)
	}
	// 4. Build source StatefulSet key
	stsKey := rb.Spec.Resource.Namespace + "." + rb.Spec.Resource.Name
	// 5. Get PV metadata Works created by PVSyncController
	workList := &workv1alpha1.WorkList{}
	if err := c.Client.List(ctx, workList, client.MatchingLabels{
		"pvsync.karmada.io/type":       "metadata",
		"pvsync.karmada.io/source-sts": stsKey,
	}); err != nil {
		klog.Errorf("Failed to list PV metadata Works for %s: %v", stsKey, err)
		return ctrl.Result{}, err
	}
	// 6. Extract clusters from RB spec
	currentClusterSet := map[string]bool{}
	for _, cluster := range rb.Spec.Clusters {
		currentClusterSet[cluster.Name] = true
	}
	// 7. Extract clusters from metadata Work namespace
	metaWorkClusterSet := map[string]bool{}
	for _, w := range workList.Items {
		clusterName, err := names.GetClusterName(w.Namespace)
		if err != nil {
			continue
		}
		metaWorkClusterSet[clusterName] = true
	}
	for cluster := range currentClusterSet {
		hasPV := false
		for _, w := range workList.Items {
			wCluster, err := names.GetClusterName(w.Namespace)
			if err != nil {
				continue
			}
			if wCluster == cluster {
				hasPV = true
				break
			}
		}
	
		if !hasPV {
			klog.Infof("[Rescheduling Detected] %s/%s: cluster %s has no PV metadata Work. Creating PV Work.", rb.Namespace, rb.Name, cluster)
	
			for _, w := range workList.Items {
				labelValue := w.Labels["pvsync.karmada.io/source-sts"]
				expected := fmt.Sprintf("%s.%s", rb.Spec.Resource.Namespace, rb.Spec.Resource.Name)
				if labelValue != expected {
					continue
				}
				for _, manifest := range w.Spec.Workload.Manifests {
					var u unstructured.Unstructured
					if err := yaml.Unmarshal(manifest.Raw, &u); err != nil {
						continue
					}
					if u.GetKind() != "ConfigMap" {
						continue
					}
					var cm corev1.ConfigMap
					if err := yaml.Unmarshal(manifest.Raw, &cm); err != nil {
						continue
					}
					for pvName, pvSpecYaml := range cm.Data {
						err := c.createPVWork(ctx, cluster, rb, pvName, pvSpecYaml)
						if err != nil {
							klog.Errorf("Failed to create PV Work for %s in cluster %s: %v", pvName, cluster, err)
						}
					}
				}
			}
		}
	}
	if err := c.finalizeFailoverIfReady(ctx, rb); err != nil {
		klog.Errorf("‚ùå Failed to finalize failover for %s/%s: %v", rb.Namespace, rb.Name, err)
	}
	return ctrl.Result{}, nil
}
func shortHash(input string) string {
	h := sha1.New()
	h.Write([]byte(input))
	return hex.EncodeToString(h.Sum(nil))[:10]
}
func (c *PVMigrationController) createPVWork(ctx context.Context, clusterName string, rb *workv1alpha2.ResourceBinding, pvName string, pvSpecYaml string) error {
	var fullpvSpec corev1.PersistentVolumeSpec
	if err := yaml.Unmarshal([]byte(pvSpecYaml), &fullpvSpec); err != nil {
		klog.Errorf("Failed to unmarshal PV spec YAML: %v", err)
		return err
	}
	var claimRef *corev1.ObjectReference
	if fullpvSpec.ClaimRef != nil {
		claimRef = &corev1.ObjectReference{
			APIVersion: fullpvSpec.ClaimRef.APIVersion,
			Kind:       fullpvSpec.ClaimRef.Kind,
			Name:       fullpvSpec.ClaimRef.Name,
			Namespace:  fullpvSpec.ClaimRef.Namespace,
		}
	}
	//ms: just copy selected field that we want
	pvSpec := corev1.PersistentVolumeSpec{
		AccessModes:                   fullpvSpec.AccessModes,
		Capacity:                      fullpvSpec.Capacity,
		ClaimRef:                      claimRef,
		PersistentVolumeReclaimPolicy: fullpvSpec.PersistentVolumeReclaimPolicy,
		StorageClassName:              fullpvSpec.StorageClassName,
		VolumeMode:                    fullpvSpec.VolumeMode,
		PersistentVolumeSource:        corev1.PersistentVolumeSource{
        		NFS: fullpvSpec.PersistentVolumeSource.NFS, 
    		},	
	}
	//ms: if pv work existed, skip
	workName := fmt.Sprintf("pv-work-%s-%s-%s", rb.Name, shortHash(pvName), clusterName) //ms: modify work name
	workNamespace := names.GenerateExecutionSpaceName(clusterName)
	existing := &workv1alpha1.Work{}
	if err := c.Client.Get(ctx, client.ObjectKey{
		Name:      workName,
		Namespace: workNamespace,
	}, existing); err == nil {
		klog.Infof("üîÅ PV Work already exists for cluster %s. Skipping creation.", clusterName)
		return nil
	}
	var existingPVs corev1.PersistentVolumeList
	if err := c.Client.List(ctx, &existingPVs); err == nil {
		for _, existingPV := range existingPVs.Items {
			if existingPV.Spec.ClaimRef != nil &&
				claimRef != nil &&
				existingPV.Spec.ClaimRef.Name == claimRef.Name &&
				existingPV.Spec.ClaimRef.Namespace == claimRef.Namespace {
					klog.Infof("üîÅ PV for PVC %s/%s already exists. Skipping creation.", claimRef.Namespace, claimRef.Name)
					return nil
				}
		}
	}
	pvcName := ""
	if claimRef != nil {
		pvcName = claimRef.Name
	}
	//ms: create pv name
	generatedName := fmt.Sprintf("pv-%s-%s", pvcName, rb.Name)
	newPV := &corev1.PersistentVolume{
		TypeMeta: metav1.TypeMeta{
			Kind:       "PersistentVolume",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: generatedName,
		},
		Spec: pvSpec,
	}
	unstructuredPV, err := helper.ToUnstructured(newPV)
	if err != nil {
		klog.Errorf("Failed to convert PV to unstructured: %v", err)
		return err
	}
	workMeta := metav1.ObjectMeta{
		Name:      workName,
		Namespace: workNamespace,
		Labels: map[string]string{
			"pvsync.karmada.io/type":       "pv-deployment",
			"pvsync.karmada.io/source-sts": rb.Spec.Resource.Namespace + "." + rb.Spec.Resource.Name,
			"pvsync.karmada.io/source-rb":  rb.Name,
			"pvsync.karmada.io/source-pv":  shortHash(pvName),
		},
	}
	if err := ctrlutil.CreateOrUpdateWork(ctx, c.Client, workMeta, unstructuredPV); err != nil {
		klog.Errorf("Failed to create PV Work for cluster %s: %v", clusterName, err)
		return err
	}
	klog.Infof("‚úÖ Created PV Work %s for cluster %s using PV %s", workName, clusterName, newPV.Name)
	return nil
}
func (c *PVMigrationController) finalizeFailoverIfReady(ctx context.Context, rb *workv1alpha2.ResourceBinding) error {
	freshPVWorkList := &workv1alpha1.WorkList{}
	if err := c.Client.List(ctx, freshPVWorkList, client.MatchingLabels{
		"pvsync.karmada.io/type":      "pv-deployment",
		"pvsync.karmada.io/source-rb": rb.Name,
	}); err != nil {
		return fmt.Errorf("failed to list PV Works: %w", err)
	}

	// 1. PV hash Í∏∞Ï§ÄÏúºÎ°ú Ï§ëÎ≥µ Ï†úÍ±∞Ìïú Í∏∞ÎåÄ Í∞úÏàò Í≥ÑÏÇ∞
	pvHashSet := make(map[string]struct{})
	for _, w := range freshPVWorkList.Items {
		pvHash := w.Labels["pvsync.karmada.io/source-pv"]
		if pvHash != "" {
			pvHashSet[pvHash] = struct{}{}
		}
	}
	expectedCount := len(pvHashSet)
	klog.Infof("üîÑ Unique PV count for readiness check: %d", expectedCount)
	if expectedCount == 0 {
		klog.Infof("üö´ No PV Works found for RB %s/%s. Skipping suspension finalize.", rb.Namespace, rb.Name)
		return nil
	}

	// 2. Î≥ëÎ†¨Î°ú PV Healthy Ïó¨Î∂Ä Í≤ÄÏÇ¨
	var availableCount int
	var mu sync.Mutex
	processed := make(map[string]struct{})
	var wg sync.WaitGroup

	for _, pvWork := range freshPVWorkList.Items {
		wg.Add(1)
		go func(pvWork workv1alpha1.Work) {
			defer wg.Done()

			latest := &workv1alpha1.Work{}
			if err := c.Client.Get(ctx, client.ObjectKeyFromObject(&pvWork), latest); err != nil {
				klog.Warningf("Failed to re-fetch PV Work: %v", err)
				return
			}

			for _, m := range latest.Status.ManifestStatuses {
				if m.Identifier.Kind == "PersistentVolume" && m.Health == "Healthy" {
					pvHash := pvWork.Labels["pvsync.karmada.io/source-pv"]
					if pvHash == "" {
						continue
					}

					mu.Lock()
					if _, ok := processed[pvHash]; !ok {
						processed[pvHash] = struct{}{}
						availableCount++
					}
					mu.Unlock()
					break
				}
			}
		}(pvWork)
	}

	wg.Wait()

	klog.Infof("‚úÖ Available PVs: %d / %d", availableCount, expectedCount)

	// 3. Ï§ÄÎπÑ ÏôÑÎ£å Ïãú suspension.dispatching Ìï¥Ï†ú
	if availableCount == expectedCount {
		if rb.Spec.Suspension != nil && rb.Spec.Suspension.Dispatching != nil && *rb.Spec.Suspension.Dispatching {
			err := retry.RetryOnConflict(retry.DefaultRetry, func() error {
				freshRB := &workv1alpha2.ResourceBinding{}
				if err := c.Client.Get(ctx, client.ObjectKeyFromObject(rb), freshRB); err != nil {
					klog.Errorf("‚ùå Failed to get fresh ResourceBinding: %v", err)
					return err
				}
				if freshRB.Spec.Suspension == nil {
					freshRB.Spec.Suspension = &workv1alpha2.Suspension{}
				}
				falseVal := false
				freshRB.Spec.Suspension.Dispatching = &falseVal

				if err := c.Client.Update(ctx, freshRB); err != nil {
					klog.Warningf("‚ùå Failed to update suspension.dispatching (inside retry): %v", err)
					return err
				}
				return nil
			})
			if err != nil {
				klog.Warningf("‚ùå Still failed to update suspension.dispatching after retries: %v", err)
				return err
			} else {
				klog.Infof("‚úÖ Successfully updated suspension.dispatching to false after retries")
			}
		}
	}

	return nil
}

func (c *PVMigrationController) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		Named(PVMigrationControllerName).
		For(&workv1alpha2.ResourceBinding{}). // no predicate, triggers on create/update
		Complete(c)
}





