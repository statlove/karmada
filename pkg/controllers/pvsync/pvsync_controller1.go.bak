package pvsync

import (
	"context"
	"fmt"
	
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	appsv1 "k8s.io/api/apps/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	meta "k8s.io/apimachinery/pkg/api/meta"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/util/sets"
	"k8s.io/client-go/tools/record"
	"k8s.io/klog/v2"
	controllerruntime "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/builder"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
	"github.com/karmada-io/karmada/pkg/util/fedinformer/genericmanager"
	"github.com/karmada-io/karmada/pkg/util/helper"
	"github.com/karmada-io/karmada/pkg/util/names"
	workv1alpha1 "github.com/karmada-io/karmada/pkg/apis/work/v1alpha1"
)

const PVSyncControllerName = "pv-sync-controller"

var persistentVolumeGVR = schema.GroupVersionResource{Group: "", Version: "v1", Resource: "persistentvolumes"}
var pvcGVR = schema.GroupVersionResource{Group: "", Version: "v1", Resource: "persistentvolumeclaims"}

type PVSyncController struct {
	client.Client
	InformerManager genericmanager.SingleClusterInformerManager
	RESTMapper      meta.RESTMapper
	EventRecorder   record.EventRecorder
}

func (c *PVSyncController) Reconcile(ctx context.Context, req controllerruntime.Request) (controllerruntime.Result, error) {
	klog.V(4).Infof("Reconciling Work %s", req.NamespacedName.String())
	work := &workv1alpha1.Work{}
	if err := c.Get(ctx, req.NamespacedName, work); err != nil {
		if apierrors.IsNotFound(err) {
			return controllerruntime.Result{}, nil
		}
		return controllerruntime.Result{}, err
	}
	if work.DeletionTimestamp != nil {
		return controllerruntime.Result{}, nil
	}

	// Only handle Works that include a StatefulSet
	if !helper.IsWorkContains(work.Spec.Workload.Manifests, appsv1.SchemeGroupVersion.WithKind("StatefulSet")) {
		return controllerruntime.Result{}, nil
	}

	return c.handleWork(ctx, work)
}

func (c *PVSyncController) handleWork(ctx context.Context, work *workv1alpha1.Work) (controllerruntime.Result, error) {
	_, err := names.GetClusterName(work.Namespace)
	if err != nil {
		return controllerruntime.Result{}, err
	}
	sts, err := extractStatefulSet(work)
        if err != nil {
                return controllerruntime.Result{}, err
        }
	pvList, err := getRelatedPVs(c.InformerManager, sts)
	if err != nil {
    		return controllerruntime.Result{}, err
	}
	if err := c.reportPVs(ctx, work, pvList); err != nil {
		return controllerruntime.Result{}, err
	}
	return controllerruntime.Result{}, nil
}

func extractStatefulSet(work *workv1alpha1.Work) (*appsv1.StatefulSet, error) {
	for _, manifest := range work.Spec.Workload.Manifests {
		obj, err := helper.ToUnstructured(&manifest)
		if err != nil || obj.GetKind() != "StatefulSet" {
			continue
		}
		sts := &appsv1.StatefulSet{}
		err = runtime.DefaultUnstructuredConverter.FromUnstructured(obj.Object, sts)
		if err != nil {
			return nil, err
		}
		return sts, nil
	}
	return nil, fmt.Errorf("no StatefulSet found in work")
}

func getRelatedPVs(informer genericmanager.SingleClusterInformerManager, sts *appsv1.StatefulSet) ([]runtime.Object, error){
	pvcNameSet := sets.NewString()
	for _, tmpl := range sts.Spec.VolumeClaimTemplates {
		for i := int32(0); i < *sts.Spec.Replicas; i++ {
			name := fmt.Sprintf("%s-%s-%d", tmpl.Name, sts.Name, i)
			pvcNameSet.Insert(name)
		}
	}
	pvcObjs, err := informer.Lister(pvcGVR).ByNamespace(sts.Namespace).List(labels.Everything())
	if err != nil {
		return nil, err
	}

	relevantPVNames := sets.NewString()
	for _, obj := range pvcObjs {
		u, ok := obj.(*unstructured.Unstructured)
		if !ok {
			continue
		}
		spec, found, _ := unstructured.NestedMap(u.UnstructuredContent(), "spec")
		if found {
			if volName, ok := spec["volumeName"].(string); ok {
				relevantPVNames.Insert(volName)
			}
		}
	}
	pvObjs, err := informer.Lister(persistentVolumeGVR).ByNamespace("").List(labels.Everything())
	if err != nil {
		return nil, err
	}

	var matched []runtime.Object
	for _, obj := range pvObjs {
		u, err := meta.Accessor(obj)
		if err != nil {
			continue
		}
		if relevantPVNames.Has(u.GetName()) {
			matched = append(matched, obj)
		}
	}
	return matched, nil
}

func (c *PVSyncController) reportPVs(ctx context.Context, work *workv1alpha1.Work, pvList []runtime.Object) error {
	for _, obj := range pvList {
		metaObj, err := meta.Accessor(obj)
		if err != nil {
			continue
		}
		newWork := &workv1alpha1.Work{
			ObjectMeta: metav1.ObjectMeta{
				Name:      fmt.Sprintf("pv-meta-%s-%s", work.Name, metaObj.GetName()),
				Namespace: work.Namespace,
				Labels: map[string]string{
					"karmada.io/pv-meta":                        "true",
					"work.karmada.io/propagationpolicy": "Suppressed",
				},
			},
			Spec: workv1alpha1.WorkSpec{
				Workload: workv1alpha1.WorkloadTemplate{
					Manifests: []workv1alpha1.Manifest{
						{RawExtension: runtime.RawExtension{Object: obj}},
					},
				},
			},
		}
		if err := c.Create(ctx, newWork); err != nil && !apierrors.IsAlreadyExists(err) {
			return err
		}
	}
	return nil
}

func (c *PVSyncController) SetupWithManager(mgr controllerruntime.Manager) error {
	return controllerruntime.NewControllerManagedBy(mgr).
		Named(PVSyncControllerName).
		For(&workv1alpha1.Work{}, builder.WithPredicates(predicate.ResourceVersionChangedPredicate{})).
		Complete(c)
}

